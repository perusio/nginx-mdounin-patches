# HG changeset patch
# User Maxim Dounin <mdounin@mdounin.ru>
# Date 1297776703 -10800
# Node ID 8cce4c8d14c8bf138c401bc90ca1e0c5005161b1
# Parent  d420362cacbf42b516127aa8a55afd13f0fb6d5d
Upstream: fix proxy_store leaving temporary files for subrequests.

Temporary files might not be removed if the "proxy_store" or "fastcgi_store"
directives were used for subrequests (e.g. ssi includes) and client closed
prematurely connection.

When client closes connection non-active subrequests are finalized out of
the control of upstream module, and code to remove unfinished temporary files
in ngx_http_upstream_process_request() isn't executed.  This patch moves
relevant code into ngx_http_upstream_finalize_request() function which is
called in all cases (either directly or via cleanup handler installed by
upstream module).

Problem was originally noted here:

http://nginx.org/pipermail/nginx-ru/2009-April/024597.html

Patch was originally posted here (no changes since then):

http://nginx.org/pipermail/nginx-ru/2009-May/024766.html

Test case is here:

http://mdounin.ru/hg/nginx-tests/rev/1d3c82227a05
http://mdounin.ru/hg/nginx-tests/file/tip/proxy-store.t

diff --git a/src/http/ngx_http_upstream.c b/src/http/ngx_http_upstream.c
--- a/src/http/ngx_http_upstream.c
+++ b/src/http/ngx_http_upstream.c
@@ -2610,7 +2610,6 @@ ngx_http_upstream_process_upstream(ngx_h
 static void
 ngx_http_upstream_process_request(ngx_http_request_t *r)
 {
-    ngx_uint_t            del;
     ngx_temp_file_t      *tf;
     ngx_event_pipe_t     *p;
     ngx_http_upstream_t  *u;
@@ -2622,30 +2621,16 @@ ngx_http_upstream_process_request(ngx_ht
 
         if (u->store) {
 
-            del = p->upstream_error;
-
-            tf = u->pipe->temp_file;
-
             if (p->upstream_eof || p->upstream_done) {
 
+                tf = u->pipe->temp_file;
+
                 if (u->headers_in.status_n == NGX_HTTP_OK
                     && (u->headers_in.content_length_n == -1
                         || (u->headers_in.content_length_n == tf->offset)))
                 {
                     ngx_http_upstream_store(r, u);
-
-                } else {
-                    del = 1;
-                }
-            }
-
-            if (del && tf->file.fd != NGX_INVALID_FILE) {
-
-                if (ngx_delete_file(tf->file.name.data) == NGX_FILE_ERROR) {
-
-                    ngx_log_error(NGX_LOG_CRIT, r->connection->log, ngx_errno,
-                                  ngx_delete_file_n " \"%s\" failed",
-                                  u->pipe->temp_file->file.name.data);
+                    u->store = 0;
                 }
             }
         }
@@ -2987,6 +2972,18 @@ ngx_http_upstream_finalize_request(ngx_h
                        u->pipe->temp_file->file.fd);
     }
 
+    if (u->store && u->pipe && u->pipe->temp_file
+        && u->pipe->temp_file->file.fd != NGX_INVALID_FILE)
+    {
+        if (ngx_delete_file(u->pipe->temp_file->file.name.data)
+            == NGX_FILE_ERROR)
+        {
+            ngx_log_error(NGX_LOG_CRIT, r->connection->log, ngx_errno,
+                          ngx_delete_file_n " \"%s\" failed",
+                          u->pipe->temp_file->file.name.data);
+        }
+    }
+
 #if (NGX_HTTP_CACHE)
 
     if (u->cacheable && r->cache) {
